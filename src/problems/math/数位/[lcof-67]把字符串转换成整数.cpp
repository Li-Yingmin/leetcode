// 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
//
//当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，
// 作为该整数的正负号；
// 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
//
//该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，
// 它们对于函数不应该造成影响。
//
//注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，
// 则你的函数不需要进行转换。
//
//在任何情况下，若函数不能进行有效的转换时，请返回 0。
//
//说明：
//
//假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−2^31, 2^31
//-1]。
// 如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或INT_MIN (−2^31) 。
//
// 输入: "4193 with words"
//输出: 4193
//解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
// 输入: "words and 987"
//输出: 0
//解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
//     因此无法执行有效的转换。
// 输入: "-91283472332"
//输出: -2147483648
//解释: 数字 "-91283472332" 超过 32 位有符号整数范围。
//     因此返回 INT_MIN (−2^31) 。
//
#include <limits>
#include <string>
using std::string;
class Solution {
 public:
  int strToInt(string str) {
    if (str.empty()) return 0;
    int sign = 1, i = 0;
    int res = 0;
    // 跳过前面的空格
    while (i < str.size() && str[i] == ' ') {
      ++i;
    }
    // 判断符号位
    while (i < str.size() && (str[i] == '-' || str[i] == '+')) {
      if (str[i] == '-') sign = -1;
      ++i;
      break;
    }
    // 读取数字，直到遇到第一个非数字字符，跳出循环
    while (i < str.size()) {
      if (str[i] >= '0' && str[i] <= '9') {
        // 判断数值是否已经超过 int 范围
        // 这里只使用了 7，而负数应该是 超过 8 才溢出，但实际上，超过 7 的负数，
        // 就是最大值 -2147483648，直接返回 min 即可
        // 超过 7 的正数肯定溢出了，直接返回 max 即可
        if (res > std::numeric_limits<int>::max() / 10 ||
            (res == std::numeric_limits<int>::max() / 10 && str[i] > '7')) {
          return sign == 1 ? std::numeric_limits<int>::max()
                           : std::numeric_limits<int>::min();
        }
        // 是数字，读取并装换整数
        res = res * 10 + (str[i] - '0');
      } else {
        // 不是数字，直接跳出循环
        break;
      }
      ++i;
    }
    // 返回结果
    return res * sign;
  }
};
